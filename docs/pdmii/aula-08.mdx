---
sidebar_position: 8
title: "Aula 08: Auth com API Real e DataStore"
description: "AuthViewModel com AndroidViewModel, KtorClient configurado com Supabase, TokenDataStore e AuthModels."
---

# Aula 08: Auth com API Real e DataStore

:::info üîÄ Branch da Aula
Esta aula refere-se √† branch: **`aula-08`**
```bash
git checkout aula-08
```
:::

## üìñ Conceito

Nesta aula, conectamos as telas de auth (Aula 06) √† **API real** hospedada no Render. O `KtorClient` agora envia headers obrigat√≥rios (`apikey`, `X-Timezone`), o `AuthViewModel` persiste tokens no **DataStore**, e os modelos de request/response s√£o definidos com **Kotlinx Serialization**.

### Arquivos novos nesta branch

| Arquivo | Descri√ß√£o |
|---------|-----------|
| `data/remote/ApiConfig.kt` | URLs e chave Supabase centralizadas |
| `data/remote/KtorClient.kt` | Atualizado com `DefaultRequest` e headers |
| `data/local/TokenDataStore.kt` | Persist√™ncia de token com DataStore |
| `domain/models/AuthModels.kt` | `User`, `LoginRequest`, `RegisterRequest`, `AuthResponse` |
| `ui/screens/auth/AuthViewModel.kt` | AndroidViewModel com login/register reais |

## üíª C√≥digo de Refer√™ncia

### ApiConfig ‚Äî Configura√ß√£o centralizada

```kotlin title="data/remote/ApiConfig.kt"
object ApiConfig {
    const val BASE_URL = "https://lddm-api-inicial-1.onrender.com"

    const val SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5c..."  // Anon Key

    object Endpoints {
        const val LOGIN = "$BASE_URL/auth/login"
        const val REGISTER = "$BASE_URL/auth/register"
        const val POSTS = "https://jsonplaceholder.typicode.com/posts"
    }
}
```

### KtorClient com DefaultRequest e Headers

```kotlin title="data/remote/KtorClient.kt"
object KtorClient {
    val httpClient = HttpClient(Android) {
        install(ContentNegotiation) {
            json(Json {
                ignoreUnknownKeys = true
                isLenient = true
            })
        }

        // Configura√ß√£o padr√£o para todas as requisi√ß√µes
        install(DefaultRequest) {
            contentType(ContentType.Application.Json)
            header("apikey", ApiConfig.SUPABASE_KEY)
            header("Authorization", "Bearer ${ApiConfig.SUPABASE_KEY}")
            header("X-Timezone", TimeZone.getDefault().id)
        }
    }
}
```

### TokenDataStore ‚Äî Persist√™ncia segura

```kotlin title="data/local/TokenDataStore.kt"
private val Context.dataStore by preferencesDataStore(name = "merge_skills_prefs")

object TokenDataStore {
    private val TOKEN_KEY = stringPreferencesKey("auth_token")

    suspend fun saveToken(context: Context, token: String) {
        context.dataStore.edit { prefs -> prefs[TOKEN_KEY] = token }
    }

    fun getToken(context: Context): Flow<String?> {
        return context.dataStore.data.map { prefs -> prefs[TOKEN_KEY] }
    }

    suspend fun clearToken(context: Context) {
        context.dataStore.edit { prefs -> prefs.remove(TOKEN_KEY) }
    }
}
```

### AuthModels ‚Äî Modelos de autentica√ß√£o

```kotlin title="domain/models/AuthModels.kt"
@Serializable
data class User(
    val id: Int,
    val username: String,
    val email: String,
    val name: String? = null,
    val role: String = "user",
    @SerialName("profile_picture")
    val profilePictureUrl: String? = null
)

@Serializable
data class LoginRequest(val email: String, val password: String? = null)

@Serializable
data class RegisterRequest(
    val name: String,
    val email: String,
    val password: String? = null,
    @SerialName("profile_picture")
    val profilePictureUrl: String? = null
)

@Serializable
data class AuthResponse(
    val token: String? = null,
    val user: User
)
```

### AuthViewModel ‚Äî Login e registro reais

```kotlin title="ui/screens/auth/AuthViewModel.kt"
data class AuthUiState(
    val isLoading: Boolean = false,
    val isSuccess: Boolean = false,
    val errorMessage: String? = null
)

class AuthViewModel(application: Application) : AndroidViewModel(application) {
    private val _uiState = MutableStateFlow(AuthUiState())
    val uiState: StateFlow<AuthUiState> = _uiState.asStateFlow()

    fun login(email: String, pass: String) {
        viewModelScope.launch {
            _uiState.value = AuthUiState(isLoading = true)
            try {
                val requestBody = LoginRequest(email = email, password = pass)
                val response: AuthResponse = KtorClient.httpClient
                    .post(ApiConfig.Endpoints.LOGIN) {
                        setBody(requestBody)
                    }.body()

                // Persiste o token no DataStore (Spec 6.4)
                response.token?.let { token ->
                    TokenDataStore.saveToken(getApplication(), token)
                }

                _uiState.value = AuthUiState(isSuccess = true)
            } catch (e: Exception) {
                _uiState.value = AuthUiState(
                    isLoading = false,
                    errorMessage = "Erro ao entrar: Verifique suas credenciais."
                )
            }
        }
    }

    fun register(name: String, email: String, pass: String) {
        viewModelScope.launch {
            _uiState.value = AuthUiState(isLoading = true)
            try {
                val requestBody = RegisterRequest(
                    name = name, email = email, password = pass
                )
                val response: AuthResponse = KtorClient.httpClient
                    .post(ApiConfig.Endpoints.REGISTER) {
                        setBody(requestBody)
                    }.body()

                response.token?.let { token ->
                    TokenDataStore.saveToken(getApplication(), token)
                }
                _uiState.value = AuthUiState(isSuccess = true)
            } catch (e: Exception) {
                _uiState.value = AuthUiState(
                    isLoading = false,
                    errorMessage = "Erro ao cadastrar: E-mail j√° existe ou falha na rede."
                )
            }
        }
    }

    fun resetError() {
        if (_uiState.value.errorMessage != null) {
            _uiState.value = _uiState.value.copy(errorMessage = null)
        }
    }

    fun resetSuccess() {
        _uiState.value = _uiState.value.copy(isSuccess = false)
    }
}
```

:::caution AndroidViewModel vs ViewModel
O `AuthViewModel` usa `AndroidViewModel(application)` porque precisa do `Context` para acessar o DataStore. Isso √© necess√°rio nesta fase do projeto ‚Äî em aulas futuras, usaremos **Koin** para injetar depend√™ncias sem precisar do `AndroidViewModel`.
:::

## üíª M√£o na Massa

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="ex1" label="Exerc√≠cio 1 ‚Äî Fixa√ß√£o" default>

### Teste o login real

Execute o app e tente fazer login com credenciais reais no endpoint do Render. Verifique no Logcat se o token √© recebido e persistido.

  </TabItem>
  <TabItem value="ex2" label="Exerc√≠cio 2 ‚Äî Aplica√ß√£o">

### Verifica√ß√£o de token no startup

No `MainActivity`, antes de navegar, verifique se j√° existe um token no DataStore:
- Se sim ‚Üí navegue direto para Home (pule Splash/Login)
- Se n√£o ‚Üí siga o fluxo normal Splash ‚Üí Login

Use `TokenDataStore.getToken(context).first()` dentro de um `LaunchedEffect`.

  </TabItem>
  <TabItem value="ex3" label="Exerc√≠cio 3 ‚Äî Desafio">

### Logout com limpeza de token

Crie um bot√£o de logout que:
1. Chame `TokenDataStore.clearToken(context)`
2. Navegue de volta para Login com `popUpTo(0)`
3. Garanta que o bot√£o "Voltar" do sistema n√£o retorne √† Home ap√≥s logout

  </TabItem>
</Tabs>
