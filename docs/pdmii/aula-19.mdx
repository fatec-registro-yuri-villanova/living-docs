---
sidebar_position: 19
title: "Aula 19: Performance e Estabilidade"
description: "Debugging, profiling, corre√ß√£o de Memory Leaks e otimiza√ß√£o de recomposi√ß√µes."
---

# Aula 19: Performance e Estabilidade

:::info üîÄ Branch da Aula
Esta aula refere-se √† branch: **`aula-19`**
```bash
git checkout aula-19
```
:::

## üìñ Conceito

Um app que funciona n√£o √© suficiente ‚Äî ele precisa funcionar **r√°pido**. L lat√™ncia mata a experi√™ncia do usu√°rio. Nesta aula, aprendemos a identificar e corrigir gargalos.

### Recomposi√ß√£o desnecess√°ria

O maior problema de performance em Compose √© a **recomposi√ß√£o excessiva**:

```kotlin
// ‚ùå RUIM: lambda recriada a cada recomposi√ß√£o
LazyColumn {
    items(courses) { course ->
        CourseCard(onClick = { viewModel.select(course.id) }) // Nova refer√™ncia!
    }
}

// ‚úÖ BOM: lambda est√°vel com remember
LazyColumn {
    items(courses, key = { it.id }) { course ->
        val onClick = remember(course.id) { { viewModel.select(course.id) } }
        CourseCard(onClick = onClick)
    }
}
```

### Ferramentas de Debug

| Ferramenta | Uso |
|-----------|-----|
| Layout Inspector | Visualizar √°rvore de Composables |
| Profiler (CPU) | Identificar fun√ß√µes lentas |
| Profiler (Memory) | Detectar memory leaks |
| `@Stable` / `@Immutable` | Dicas para o compilador Compose |
| StrictMode | Detectar opera√ß√µes no main thread |

### derivedStateOf

```kotlin
// Evita recomposi√ß√µes quando o valor calculado n√£o muda
val showCompletionBanner by remember {
    derivedStateOf { uiState.courses.all { it.isCompleted } }
}
```

## üíª C√≥digo de Refer√™ncia

```kotlin title="Otimiza√ß√£o de LazyColumn"
@Composable
fun OptimizedCourseList(
    courses: List<Course>,
    onCourseClick: (String) -> Unit
) {
    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        items(
            items = courses,
            key = { it.id },          // Identidade est√°vel
            contentType = { "course" } // Otimiza pool de composables
        ) { course ->
            // remember evita realoca√ß√£o da lambda
            val onClick = remember(course.id) { { onCourseClick(course.id) } }
            StitchCard(
                title = course.title,
                subtitle = "${course.completedLessons}/${course.totalLessons}",
                modifier = Modifier.clickable(onClick = onClick)
            )
        }
    }
}
```

## üíª M√£o na Massa

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
  <TabItem value="ex1" label="Exerc√≠cio 1 ‚Äî Fixa√ß√£o" default>

### Adicione `key` em todas as LazyColumns

Revise o projeto e garanta que toda `LazyColumn` com `items()` usa o par√¢metro `key` com um identificador est√°vel.

  </TabItem>
  <TabItem value="ex2" label="Exerc√≠cio 2 ‚Äî Aplica√ß√£o">

### Use o Layout Inspector

Abra o **Layout Inspector** no Android Studio e identifique pelo menos 2 Composables que recomp√µem desnecessariamente. Corrija-os usando `remember` ou `derivedStateOf`.

  </TabItem>
  <TabItem value="ex3" label="Exerc√≠cio 3 ‚Äî Desafio">

### Profiling e Memory Leaks

Use o **Memory Profiler** para:
1. Navegar entre Home ‚Üí Curso ‚Üí Quiz ‚Üí Home repetidamente
2. Capturar um heap dump e verificar se h√° objetos retidos
3. Corrigir qualquer leak encontrado (geralmente Coroutines n√£o canceladas ou refer√™ncias a Context)
4. Documentar as corre√ß√µes feitas

  </TabItem>
</Tabs>
